(define (square x) (* x x))
(define (divides? a b)
  (= (remainder b a) 0))
(define (smallest-divisor n)
  (define (find-divisor n test)
    (cond ((> (square test) n) n)
          ((divides? test n) test)
          (else (find-divisor n (+ test 1)))))
  (find-divisor n 2))
(define (prime? n)
  (= n (smallest-divisor n)))

 (define (timed-prime-test n) 
     (start-prime-test n (runtime))) 
 (define (start-prime-test n start-time) 
     (if (fast-prime? n 12) 
         (report-prime n (- (runtime) start-time)) 
         #f)) 
 (define (report-prime n elapsed-time) 
     (display n) 
     (display "***") 
     (display elapsed-time) 
     (newline))

  ;search counter 
 (define (search-for-primes n counter) 
   (if (even? n) 
       (s-f-p (+ n 1) counter) 
       (s-f-p n counter))) 
 ;it's important to pay attention to the fact that predicate of the first 'if' here calls (timed-prime-test n) which in case of #t  computes into two procedures - (report-prime n (elapsed-time)) and 'then' case of the first 'if'.  
 (define (s-f-p n counter) 
     (if (> counter 0) 
       (if (timed-prime-test n) 
           (s-f-p (+ n 2) (- counter 1)) 
           (s-f-p (+ n 2) counter)) 
       "COMPUTATION COMPLETE"))

(define (fast-prime? n times)
  (define (expmod base exp m)
    (cond ((= exp 0) 1)
          ((even? exp)
           (remainder
            (square (expmod base (/ exp 2) m))
            m))
           (else
            (remainder
             (* base (expmod base (- exp 1) m))
             m))))
  (define (fermat-test n)
    (define (try-it a)
      (= (expmod a n n) a))
    (try-it (+ 1 (random (- n 1)))))
  (cond ((= times 0) true)
        ((fermat-test n)
         (fast-prime? n (- times 1)))
        (else false)))
 
 (search-for-primes 3000000000 3)